# Project Cursor Rules

## UI/UX Standards

### Skeleton Loading (REQUIRED)

**ALWAYS use skeleton loading instead of spinners or circular progress indicators.**

#### Implementation Requirements:

1. **Never use CircularProgress or spinner components** for loading states
2. **Always use Skeleton components** from `@mui/material` or custom skeleton loaders
3. Skeleton loaders should **match the layout** of the actual content being loaded
4. Show **meaningful structure** during loading (cards, lists, forms, etc.)
5. Maintain **consistent spacing and sizing** between skeleton and actual content

#### Available Skeleton Components:

- `StatCardSkeleton` - For dashboard statistics cards
- `ReviewCardSkeleton` - For review list items
- `CompanyCardSkeleton` - For company cards
- `ProfileSectionSkeleton` - For profile sections
- `KeywordChipSkeleton` - For keyword chips
- `ContentSkeleton` - Generic content skeleton

Location: `/reviews/src/components/SkeletonLoaders.tsx`

#### Example Pattern:

```tsx
if (loading) {
  return (
    <Container maxWidth="xl" sx={{ py: 4 }}>
      <Stack spacing={4}>
        <Typography variant="h4">Dashboard</Typography>
        <Typography variant="body1" color="text.secondary">
          Loading your data...
        </Typography>

        <Box
          sx={{
            display: "grid",
            gridTemplateColumns: "repeat(4, 1fr)",
            gap: 3,
          }}
        >
          {[1, 2, 3, 4].map((i) => (
            <StatCardSkeleton key={i} />
          ))}
        </Box>
      </Stack>
    </Container>
  );
}
```

#### Why Skeleton Loading:

- **Better UX**: Users see the structure of content before it loads
- **Perceived Performance**: Makes the app feel faster
- **Reduces Layout Shift**: Content doesn't jump when it loads
- **Professional**: Modern apps (Facebook, LinkedIn, etc.) use skeleton loading
- **Apple-like**: Aligns with minimalist, smooth user experience

### Design System

- Follow Apple.com's minimalist aesthetic
- Clean, spacious layouts with generous whitespace
- Subtle shadows and borders
- Smooth transitions and animations
- Typography: SF Pro Display/Text font stack
- Colors: Black (#000000), Blue (#0071e3), Gray tones
- Border radius: 12-18px for cards, 980px for buttons

### Component Standards

- Cards: 18px border radius, subtle shadows
- Buttons: Pill-shaped (980px radius), no text transform
- Spacing: Generous padding and margins (multiples of 8px)
- Typography: Proper letter-spacing and font weights

### Performance

- Always show loading states with skeleton loaders
- Optimize images and assets
- Lazy load when appropriate
- Minimize layout shifts

## Component Architecture

### Self-Contained Components (REQUIRED)

**ALWAYS create self-contained components with minimal dependencies.**

#### Implementation Requirements:

1. **Minimal Props**: Only pass essential data, avoid passing entire objects when possible
2. **Self-Contained Logic**: Include all necessary logic within the component
3. **Clear Interfaces**: Define explicit prop interfaces with TypeScript
4. **Single Responsibility**: Each component should have one clear purpose
5. **Reusable**: Components should be reusable across different contexts
6. **No External Dependencies**: Avoid dependencies on specific parent components

#### Component Creation Guidelines:

```tsx
// ✅ GOOD - Self-contained component
interface UserCardProps {
  userId: string;
  userName: string;
  userEmail: string;
  onEdit: (userId: string) => void;
}

export const UserCard = ({
  userId,
  userName,
  userEmail,
  onEdit,
}: UserCardProps) => {
  // All logic contained within component
  const handleEdit = () => onEdit(userId);

  return (
    <Card>
      <CardContent>
        <Typography variant="h6">{userName}</Typography>
        <Typography variant="body2">{userEmail}</Typography>
        <Button onClick={handleEdit}>Edit</Button>
      </CardContent>
    </Card>
  );
};

// ❌ BAD - Tightly coupled component
interface BadUserCardProps {
  user: User; // Passing entire object
  company: Company; // Unnecessary dependency
  onEdit: (user: User, company: Company) => void; // Complex callback
}
```

#### Benefits:

- **Reusability**: Components can be used in multiple contexts
- **Testability**: Easier to unit test with clear interfaces
- **Maintainability**: Changes to one component don't affect others
- **Performance**: Smaller prop changes trigger fewer re-renders
- **Clarity**: Clear separation of concerns

#### Examples of Self-Contained Components:

- `CompanyHeader` - Takes company data, renders header
- `FetchPlatformReviews` - Takes platforms array, renders platform buttons
- `ReviewCard` - Takes review data, renders review display
- `LocationCard` - Takes location data, renders location info

## MUI Grid Component Fix

### Problem

MUI Grid components may show TypeScript errors about missing `item` prop or `xs`/`sm`/`md` props not being recognized.

### Solution

Based on MUI version, use the correct Grid component:

```tsx
// ✅ CORRECT - MUI v7+ (Current Grid component)
import { Grid } from '@mui/material';

<Grid container spacing={3}>
  <Grid size={{ xs: 12, sm: 6, md: 3 }}>
    {/* content */}
  </Grid>
</Grid>

// ✅ ALTERNATIVE - MUI v5/v6 (Grid2 component)
import { Grid2 as Grid } from '@mui/material';

<Grid container spacing={3}>
  <Grid xs={12} sm={6} md={3}>
    {/* content */}
  </Grid>
</Grid>

// ❌ AVOID - Legacy Grid with item prop (deprecated in v7)
<Grid item xs={12} sm={6} md={3}>  // Deprecated in v7
```

### Implementation Steps:

1. **Check MUI version**: `npm list @mui/material`
2. **If MUI v7+**: Use `Grid` with `size` prop (no `item` prop)
3. **If MUI v5/v6**: Use `Grid2` import with individual size props
4. **Always test**: Verify Grid layout works correctly

### Migration Guide:

- **v7**: `item` prop removed, use `size={{ xs: 12, sm: 6 }}` instead of `xs={12} sm={6}`
- **v6**: Size props renamed to `size` prop
- **v5**: Use `Grid2` import for new Grid component

### Common Error Patterns to Fix:

- `Property 'item' does not exist` → Remove `item` prop, use `size` prop
- `Property 'xs' does not exist` → Use `size={{ xs: 12 }}` format
- `No overload matches this call` → Check MUI version and use correct Grid component

## Database Migrations

### Supabase Migration Creation (REQUIRED)

**ALWAYS use Supabase CLI to create new migration files.**

#### Implementation Requirements:

1. **Never manually create migration files** in `supabase/migrations/`
2. **Always use Supabase CLI command**: `supabase migration new <migration_name>`
3. Migration names should be descriptive and use snake_case
4. The CLI automatically generates a timestamped filename (e.g., `YYYYMMDDHHMMSS_migration_name.sql`)

#### Example:

```bash
# ✅ CORRECT - Create migration using Supabase CLI
supabase migration new add_french_localization_to_features

# This creates: supabase/migrations/YYYYMMDDHHMMSS_add_french_localization_to_features.sql

# ❌ AVOID - Manually creating migration files
# Do NOT create files like: supabase/migrations/20250207000005_add_french_localization_to_features.sql
```

#### Migration Naming Convention:

- Use descriptive, snake_case names
- Examples:
  - `add_french_localization_to_features`
  - `update_user_platforms_access`
  - `create_platform_logo_bucket`
- The timestamp prefix is automatically added by the CLI

#### Why Use Supabase CLI:

- **Consistency**: Ensures proper timestamp format and naming
- **Version Control**: Tracks migration order correctly
- **Best Practice**: Aligns with Supabase documentation and tooling
- **Error Prevention**: Avoids duplicate timestamps or naming conflicts

## Code Cleanup (REQUIRED)

### Remove Unused Code After Edits (REQUIRED)

**ALWAYS delete unused variables, methods, functions, components, and imports after completing edits.**

#### Implementation Requirements:

1. **Remove Unused Variables**: Delete any variables that are declared but never used
2. **Remove Unused Methods/Functions**: Delete any functions or methods that are defined but never called
3. **Remove Unused Components**: Delete any React components that are created but never rendered or imported
4. **Remove Unused Imports**: Delete any import statements for modules, types, or functions that are no longer used
5. **Remove Unused Type Definitions**: Delete any TypeScript interfaces, types, or enums that are no longer referenced
6. **Clean Up After Refactoring**: When refactoring code, ensure all old/unused code paths are removed

#### When to Clean Up:

- **After every edit session**: Before finishing, review the modified files for unused code
- **After refactoring**: When changing implementation, remove old code that's no longer needed
- **After feature completion**: When a feature is done, remove any temporary or unused code
- **Before committing**: Ensure no unused code is left in the codebase

#### How to Identify Unused Code:

1. **TypeScript/ESLint warnings**: Pay attention to compiler warnings about unused variables
2. **IDE indicators**: Most IDEs highlight unused imports and variables
3. **Manual review**: Check if variables/functions are referenced anywhere
4. **Search the codebase**: Use grep/search to verify if code is used elsewhere

#### Example Pattern:

```tsx
// ❌ BAD - Unused code left in file
import { useState, useEffect, useCallback } from 'react'; // useEffect unused
import { Button, Card, Typography, Box } from '@mui/material'; // Box unused

const MyComponent = () => {
  const [count, setCount] = useState(0);
  const [unusedState, setUnusedState] = useState(''); // Unused state
  const unusedVariable = 'test'; // Unused variable

  const unusedFunction = () => { // Unused function
    console.log('never called');
  };

  return (
    <Card>
      <Typography>{count}</Typography>
      <Button onClick={() => setCount(count + 1)}>Increment</Button>
    </Card>
  );
};

// ✅ GOOD - Clean code with only what's used
import { useState } from 'react';
import { Button, Card, Typography } from '@mui/material';

const MyComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <Card>
      <Typography>{count}</Typography>
      <Button onClick={() => setCount(count + 1)}>Increment</Button>
    </Card>
  );
};
```

#### Benefits:

- **Cleaner Codebase**: Easier to read and maintain
- **Reduced Bundle Size**: Unused imports and code increase bundle size
- **Better Performance**: Less code to parse and execute
- **Easier Debugging**: Less clutter makes finding issues easier
- **Professional Standards**: Production code should be clean and minimal

#### Exceptions:

- **Commented-out code for reference**: Can be kept temporarily if explicitly needed for context
- **Code marked with TODO/FIXME**: Keep if it's intentional future work
- **Exported functions/components**: If exported, they may be used externally (verify before removing)
